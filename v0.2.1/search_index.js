var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#LazyReports.LazyReports","page":"API","title":"LazyReports.LazyReports","text":"LazyReports\n\nLazy reports in Julia.\n\n\n\n\n\n","category":"module"},{"location":"api/#LazyReports.LazyReport","page":"API","title":"LazyReports.LazyReport","text":"struct LazyReport\n\nRepresents a lazy report.\n\nDon't instantiate directly, use lazyreport()\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyReports.LazyTable","page":"API","title":"LazyReports.LazyTable","text":"struct LazyReports.LazyTable\n\nRepresents a lazy table.\n\nSupports convert(::Type{Markdown.Table}, lt::LazyTable).\n\nDon't instantiate directly, use lazytable.\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyReports.OpaqueContent","page":"API","title":"LazyReports.OpaqueContent","text":"struct OpaqueContent\n\nRepresents opaque content with a specific MIME type.\n\nConstructors:\n\nOpaqueContent(data::AbstractVector{UInt8}, mime::MIME)\n\nOpaqueContent(mime::MIME) do io\n    # add something to io::IO\nend\n\nExample:\n\ncontent = OpaqueContent(MIME(\"text/html\")) do io     println(io, \"<p>Hello, World!</p>\") end lazyreport(content)\n\n\n\n\n\n","category":"type"},{"location":"api/#LazyReports.lazyreport","page":"API","title":"LazyReports.lazyreport","text":"lazyreport()\nlazyreport(contents...)\nlazyreport(contents...)\n\nGenerate a lazy report, e.g. a data processing report.\n\nUse lazyreport!(rpt, contents...) to add more content to a report.\n\nExample:\n\nusing LazyReports, StructArrays, IntervalSets, Plots\n\ntbl = StructArray(\n    col1 = rand(5), col2 = ClosedInterval.(rand(5), rand(5).+1),\n    col3 = [rand(3) for i in 1:5], col4 = rand(Bool, 5),\n    col5 = [:a, :b, :c, :d, :e], col6 = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n    col7 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])]\n)\n\nrpt = lazyreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlazyreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlazyreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))\n\nshow(stdout, MIME\"text/plain\"(), rpt)\nshow(stdout, MIME\"text/html\"(), rpt)\nshow(stdout, MIME\"text/markdown\"(), rpt)\n\nwrite_lazyreport(\"report.txt\", rpt)\nwrite_lazyreport(\"report.html\", rpt)\nwrite_lazyreport(\"report.md\", rpt)\n\nImplementation\n\nDo not specialize lazyreport directly, specialize the lower-level function LazyReports.pushcontent! instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyReports.lazyreport!-Tuple{LazyReports.LazyReport, Vararg{Any}}","page":"API","title":"LazyReports.lazyreport!","text":"lazyreport!(rpt::LazyReport, contents...)\n\nAdd more content to report rpt. See lazyreport for an example.\n\nImplementation\n\nDo not specialize lazyreport!(rpt::LazyReport, obj::MyType) directly, specialize the lower-level function LazyReports.pushcontent! instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#LazyReports.lazytable","page":"API","title":"LazyReports.lazytable","text":"lazytable(tbl; headers = missing)\n\nWrap/convert a Tables.jl-compatible tbl an return a LazyTable, for use with lazyreport.\n\nIf headers is missing, default headers are generated from the column names of tbl. If headers is an AbstractDict, the default column names are overridden according to the keys and values in it. If headers is an AbstractVector, it explicitly defines all headers of the table and must have the same length as the number of columns in tbl.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyReports.pushcontent!","page":"API","title":"LazyReports.pushcontent!","text":"LazyReports.pushcontent!(rpt::LazyReport, obj)\n\nLower-level function to add a single object to report rpt.\n\nUsers should call lazyreport!(rpt, obj) instead, but should specialize LazyReports.pushcontent!(rpt::LazyReport, obj::MyType) to control how objects of specific types are added to reports (e.g. by converting them to Markdown, tables, or other content types first).\n\nThe return value of pushcontent! is undefined and should be ignored.\n\nImplementation\n\nSpecialized methods of pushcontent! that convert obj to types already supported by LazyReport should preferably call lazyreport! internally instead of calling pushcontent! again directly.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyReports.render_element","page":"API","title":"LazyReports.render_element","text":"LazyTable.render_element(io::IO, mime::MIME, obj::Any)\n\nRender obj for the given mime type to io.\n\nDefaults to show(io, mime, obj), with show(io, MIME(\"text/plain\"), obj) as a fallback if showable(mime, obj) == false.\n\nShould be specialized for specific combinations of MIME and object types if specialization of Base.show would be too broad.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyReports.render_inline","page":"API","title":"LazyReports.render_inline","text":"LazyTable.render_inline(io::IO, mime::MIME, obj::Any)\n\nRender obj as inline content for the given mime type to io.\n\nDefaults to render_element(io, mime, obj) and may be specialized for specific combinations of MIME and object types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyReports.render_intable","page":"API","title":"LazyReports.render_intable","text":"LazyTable.render_intable(io::IO, mime::MIME, obj::Any)\n\nRender obj as table cell content for the given mime type to io.\n\nDefaults to render_inline(io, mime, obj) and may be specialized for specific combinations of MIME and object types.\n\n\n\n\n\n","category":"function"},{"location":"api/#LazyReports.write_lazyreport","page":"API","title":"LazyReports.write_lazyreport","text":"write_lazyreport(filename::AbstractString, rpt::LazyReport)\nwrite_lazyreport(filename::AbstractString, mime::MIME, rpt::LazyReport)\n\nWrite lazyreport rpt to file filename.\n\n\n\n\n\n","category":"function"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#LazyReports.jl","page":"Home","title":"LazyReports.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LazyReports provides report generation with minimal dependencies; thus, depending on LazyReports should have minimal load-time impact for Julia packages. Reports are a mixture of text and data objects, and are lazy in the sense that they are easy to create and their contents are only rendered when the report is displayed or written to a file. This way, reports can be generated as part of algorithms and workflows with only a small runtime overhead.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The central function of the package is lazyreport. It generates a report object that can be rendered (via show and display) in different MIME types. lazyreport allows for appending content to reports.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reports are displayed automatically in the REPL (as far as supported by the report objects), in Jupyter and Pluto notebooks, and in Visual Studio Code (when using the Julia extension). Reports can also be written to files using write_lazyreport.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the types the current Julia display supports, LazyReports also has special support for StatsBase.Histogram (one-dimensional only).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LazyReports, StructArrays, StatsBase, Plots\n\ntbl = StructArray(\n    col1 = rand(5),\n    col2 = [rand(3) for i in 1:5],\n    col3 = [:(a[1]), :(a[2]), :(a[3]), :(a[4]), :(a[5])],\n    col4 = [fit(Histogram, rand()^3 * 1000 * randn(10^4), nbins = 50) for i in 1:5],\n)\n\nrpt = lazyreport(\n    \"# New report\",\n    \"Table 1:\", tbl\n)\nlazyreport!(rpt, \"Figure 1:\", stephist(randn(10^3)))\nlazyreport!(rpt, \"Figure 2:\", histogram2d(randn(10^4), randn(10^4), format = :png))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The lower-level function LazyReports.pushcontent! can be specialized to control how objects of specific types are added to reports (e.g. by converting them to Markdown, tables or supported content types first).","category":"page"},{"location":"#Lazy-tables","page":"Home","title":"Lazy tables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"lazytable wraps/converts Tables.jl-compatible objects and allows for adding custom column labels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using IntervalSets\n\ntbldata = (\n    a = ClosedInterval.(rand(5), rand(5).+1),\n    b = rand(Bool, 5),\n    c = [\"a\", \"b\", \"c\", \"d\", \"e\"],\n)\n\nlazyreport(\n    \"# Table report\",\n    lazytable(tbldata, headers = Dict(:a => \"Intervals\", :b => \"Booleans\", :c => \"Strings\"))\n)","category":"page"},{"location":"#Rendering-Plots","page":"Home","title":"Rendering Plots","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When rendering reports using MIME(\"text/plain\"), e.g. when showing reports on the REPL and when writing reports to \".txt\" files, LazyReports will try to convert Plots.jl plots to the Plots.UnicodePlotsBackend. UnicodePlots will be loaded automatically, but the package UnicodePlots must be part of your Julia environment or rendering will fail. Note that converting Plots generated with a different backend (e.g. the default GR backend) to UnicodePlots will not always yield satisfactory results, depending on the type of plot.","category":"page"}]
}
